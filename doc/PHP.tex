\documentclass{article}
\usepackage[latin1]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{threeparttable}
\usepackage{lscape}
\usepackage{amsmath}
\usepackage{pdfpages}

\begin{document}

\title{Automatisierung der WSUS Auswertung
\\ Ein Projekt mit PHP\textbackslash MSSQL}
\author{Gennaro Piano}
\date{\today}

\maketitle

\begin{figure}[htbp]
		\centering
	\includegraphics[width=10cm]{wsus.jpg}
		\label{fig:logo}
\end{figure}

\newpage
\tableofcontents
\newpage
\section{Einleitung}
\subsection{Ausgangslage}
Wir bieten unseren Kunden die Möglichkeit die Windows Updates über unserem WSUS Server herunterzuladen. Durch dieses Angebot muss sich der Kunde nicht mehr über fehlerhaften Updates kümmern, da wir die Updates zuerst in einer Testumgebung testen und diese danach freigeben. Um die Updateverwaltung einfach zu halten wurden auf dem WSUS Server Produktklassen erstellt. Computer und Server von Kunden die unser Angebot nutzen möchten, werden den entsprechenden Produktklassen zugeteilt. Updates die freigegeben sind werden wiederum den entsprechenden Produktklassen zugeteilt und somit auf den Geräten der Kunden installiert. Dieses System ist gut durchdacht, jedoch ist es sehr kompliziert diese Daten auszuwerten. \newline \newline
Um die Daten auszuwerten werden jedes Quartal alle freigegebenen Updates manuell in einer Excel Datei aufgenommen. Jedes Update wird danach in die entsprechende Produktklasse kopiert. Auf einem weiterem Excel Blatt wird ausgewertet, welcher Benutzer welche Produktklassen benötigt. Dieser Prozess ist sehr zeitintensiv und kostet pro Quartal circa eins bis zwei Arbeitstage.
\subsection{Ziel der Arbeit}
Um den Aufwand zu kürzen soll der Ablauf des Prozesses so weit wie möglich automatisiert werden. Dies soll mit PHP und einem MS SQL Server realisiert werden. Im ersten Schritt soll die Verbindung zwischen den Updates und den Produktklassen programmiert werden. Als zweiter Schritt werden die Kunden hinzugefügt und die Auswertung automatisiert. Diese Arbeit befasst sich mit dem ersten Schritt des Projekts.
\subsection{Sourcecode}
Der Sourcecode der Applikation wurde aus Platzgründen nicht in die Dokumentation eingefügt, jedoch kann er direkt aus dem GitHub Repository heruntergeladen werden. Der Link lautet https://github.com/pianogen/auswertung.
\subsection{Bemerkung}
Die Applikation wird auf einer virtuellen Maschine entwickelt und getestet, sobald alle das Projekt abgeschlossen ist, werden die Dateien auf den produktiven Server kopiert.
\newpage
\section{Requierements}
\subsection{Einleitung}
\textbf{Zweck} \newline
Dieser Teil des Dokuments befasst sich mit den Anforderungen, des Projekts. Diese Anforderungen werden mit dem Auftraggeber angeschaut. Erst wenn die Anforderungen vom Auftraggeber bestätigt worden sind und nach seiner Meinung alles abgedeckt ist, wird das Projekt fortgeführt.
\newline
\newline
\textbf{Systemumfang} \newline
Das System wird für den internen Gebrauch entwickelt und soll von aussen nicht zugänglich sein. Somit besteht keine Gefahr, die Applikation vor unerlaubten Zugriff zu schützen, da dies die Firewall handhabt. 
\newline
\newline
\textbf{Auftraggeber} \newline
Der Auftraggeber dieses Projekts ist zugleich der interne technische Leiter der Firma. Somit wird das Projekt als internes Projekt gehandhabt. Der technische Leiter ist kein Programmierer und stellt deswegen keine technische Anforderungen an das Projekt. Der technische Leiter wird für dieses Projekt als Kunde angesehen.\newline \newline
\subsection{Allgemeine Übersicht}
\textbf{Systemumfeld} \newline
Diese Applikation benötigt einen Webserver und eine Schnittstelle zu einer Microsoft SQL Datenbank. Der WSUS Server gehört auch zum Systemumfeld, jedoch ist die Verbindung zwischen dem WSUS Server und der Applikation nur abstrakt, da die entnommenen Informationen aus dem WSUS Server manuell in der Applikation aufgenommen werden.
\begin{figure}[htbp]
		\centering
	\includegraphics[width=10cm]{C:/inetpub/wwwroot/auswertung/doc/img/Systemumfeld.jpg}
		\label{fig:Systemumfeld}
\end{figure}
\newpage
\parindent0pt \textbf{Architekturbeschreibung} \newline
Die PHP Applikation wird auf dem schon vorhandenen Webserver implementiert. Es handelt sich um einen IIS, dies ist der Webserver von Microsoft. Der IIS unterstützt von sich aus kein PHP. Somit muss der PHP Interpreter nachgerüstet werden. Der PHP Interpreter wird mit dem integrierten Webplattform Installer installiert. Für die Datenbankanbindung wird ebenfalls der vorhandene SQL Server benutzt. Auf diesem Server wird eine neue Datenbank und ein neuer Datenbankbenutzer erstellt. Der neue Benutzer wird nur auf diese Datenbank Zugriff haben, zugleich wird er der einzige Benutzer sein, der auf die neue Datenbank Zugriff hat. Der Webserver und der SQL Server befinden sich physikalisch auf dem gleichen Server, somit ist hardwaremässig nur ein Server von den Veränderungen betroffen. Der PHP Interpreter benötigt eine Schnittstelle um auf die Datenbank zu lesen und zu schreiben, die Schnittstelle zwischen PHP und einem Microsoft SQL Server wird nicht automatisch installiert und muss somit manuell nachinstalliert werden.
\newline
\newline
\textbf{Systemfunktionalität} \newline
Das Use Case Diagramm soll die Funktionalität des Systems aufzeigen.
\begin{figure}[htbp]
		\centering
	\includegraphics[width=14.5cm]{C:/inetpub/wwwroot/auswertung/doc/img/Use_Case.jpg}
		\label{fig:UseCaseDiagramm}
\end{figure}
\newpage
\parindent0pt \textbf{Nutzer und Zielgruppen} \newline
Der Hauptnutzer ist zugleich der Auftraggeber dieses Projekts. Neben dem Auftraggeber wird die Webapplikation auch von seinem Stellvertreter benutzt werden, dies wird jedoch sehr selten der Fall sein. Der Zugriff auf die Webapplikation wird für alle Benutzer des Unternehmens möglich sein, dies ist bei der momentanen Excel Datei auch der Fall.
\newline
\newline
\textbf{Annahmen} \newline
Der zweite Teil des Projekts wird wie oben bereits erwähnt erst später entwickelt. In dieser Dokumentation wird auf den zweiten Teil des Projekts bewusst nicht eingegangen, da dies ansonsten den Umfang dieses Dokuments sprengen würde.
\subsection{Anforderungen}
\begin{itemize}
\item Die Applikation muss dem Benutzer ermöglichen, neue Updateeinträge durch eine Maske in die Datenbank einzutragen. 
\item Die Applikation muss dem Benutzer ermöglichen, über eine Maske nach Updateeinträge auf der Datenbank zu suchen. 
\item Die Applikation muss dem Benutzer ermöglichen, über eine Maske Updateeinträge auf der Datenbank zu verändern und zu löschen. 
\item Die Applikation muss dem Benutzer ermöglichen, neue Packageeinträge durch eine Maske in die Datenbank einzutragen. 
\item Die Applikation muss dem Benutzer ermöglichen, über eine Maske nach Packageeinträge auf der Datenbank zu suchen. 
\item Die Applikation muss dem Benutzer ermöglichen, über eine Maske Packageeinträge auf der Datenbank zu verändern und zu löschen. 
\item Die Applikation muss dem Benutzer alle Packagezuweisungen eines Updateeintrags aufzeigen, wenn der Benutzer den Updateeintrag anschaut. 
\item Die Applikation muss dem Benutzer ermöglichen, über eine Maske ein Packageeintrag, dem entsprechendem Typ zuzuordnen. 
\item Andersum soll die Applikation dem Benutzer alle Updateeinträge eines Packages aufzeigen, wenn der Benutzer den Packageeintrag anschaut. 
\item Sobald der Benutzer einen neuen Updateeintrag eröffnen will, soll die Applikation ihm die Packages aufzeigen, damit er sogleich die Verknüpfung erstellen kann.
\end{itemize}
\newpage
Beim Speichervorgang des neuen Eintrag soll das System folgende Einträge die durch den Benutzer erfolgt sind überprüfen:
\begin{itemize}
\item Der Titel eines Updateeintrag darf nicht leer sein.
\item Die KB Nummer eines Updateeintrags darf nicht leer sein und muss einen numerischen Wert haben.
\item Das Veröffentlichungsdatum eines Updateeintrags darf nicht leer sein.
\item Ein Updateeintrag kann mehreren Packages zugeteilt werden.
\item Datumsfelder werden nur als dd.mm.JJJJ angenommen
\item Ein Updateeintrag kann keinem Package zugeteilt werden.
\item Ein Update kann von Microsoft auch zurückgezogen werden, dies sollte ebenfalls im Datensatz aufgenommen werden können. Dieser kann auch leer sein.
\item Sobald der ein Update mindestens einem Package zugeteilt worden ist, muss der Benutzer auch ein Approvement Daten setzen. 
\item Falls das Update keinem Package zugeteilt worden ist, darf kein Approvement Datum gesetzt sein.
\item Der Titel eines Packageeintrag darf nicht leer sein.
\item Der Typ eines Packageeintrag darf nicht leer sein.
\end{itemize}
Falls eine dieser Überprüfungen fehlschlägt, darf der Eintrag nicht gespeichert werden. Die Anforderungen des Speicher- und Änderungsvorgangs sind identisch. Das Löschen eines Updateeintrag muss die Verknüpfung zu den zugeteilten Packages ebenfalls löschen. Das Löschen eines Packageeintrag muss wiederum die Verknüpfungen zu den implementierten Updates löschen.
\subsection{Analyse der Anforderungen}
\newpage
\section{Entwicklung}
\subsection{Datenbank}
Um die aufgenommenen Updates zu speichern, wird eine Datenbank benötigt. Vor der Erstellung der Datenbank wurde ein Entity Relationship Diagram erstellt. Auf der nächsten Seite befindet sich ein genaue Beschreibung der Tabellen und Attributen. Der Text in Klammern beschreibt die Eigenschaften der Attributen.
\begin{figure}[htbp]
		\centering
	\includegraphics[width=14.5cm]{C:/inetpub/wwwroot/auswertung/doc/img/Datenbank.jpg}
		\label{fig:Datenbank}
\end{figure}
\newpage
\subsubsection{Tabelle update}
In dieser Tabelle befinden sich alle Informationen, die ein Update benötigt.
\begin{itemize}
\item \textbf{id} (Primärschlüssel, int, auto increment, NOT NULL) \newline 
Wird für die Verbindung zur Tabelle update\_package benötigt. 
\item \textbf{name} (varchar(400), NOT NULL) \newline 
Das ist der Titel des Updates, da der Titel recht lange sein kann, wird der String auf 400 Zeichen begrenzt. Diese Attribut ist ein Pflichtfeld.
\item \textbf{kb} (int, NOT NULL) \newline
Das ist die KB Nummer\footnote{Knowlegde Base Number: Wird für Microsoft genutzt, um Updates eindeutig zu kennzeichnen} des Updates. Dieses Attribut wurde nicht als Primary Key benutzt, da es schon vorgekommen ist, das zwei Updates die selbe KB Nummer haben. Dieses Attribut ist ein Pflichtfeld, da jedes Update eine KB Nummer hat.
\item \textbf{release} (date, NOT NULL) \newline
Dieses Attribut beinhaltet das Erscheinungsdatum des Updates. Es ist ein Pflichtfeld, da jedes Update dass eingetragen wird, schon erschienen ist.
\item \textbf{decline} (date) \newline
Falls ein Update von Microsoft wegen einem Bug zurückgenommen wird, wird dieses Datum in diesem Feld eingefügt.
\item \textbf{approve\_clt} (date)  \newline 
Dieses Attribut beinhaltet das Datum, an dem das Update für die Clients freigegeben wurde. Dieses Feld darf leer sein, da nicht jedes Update zwingend für Clients ist.
\item \textbf{approve\_srv} (date) \newline
Dieses Attribut beinhaltet das Datum, an dem das Update für die Server freigegeben wurde. Dieses Feld darf leer sein, da nicht jedes Update zwingend für Server ist.
\end{itemize}
\subsubsection{Tabelle update\_package}
Diese Tabelle ist eine Zwischentabelle. Durch diese Tabelle wird die Beziehung zwischen den Tabellen update und package ermöglicht. In dieser Tabelle besteht der Primärschlüssel aus zwei Attributen.
\begin{itemize}
\item \textbf{updateId} (Primary Key, int, NOT NULL) \newline 
Dieses Attribut enthält von jedem Update, welches mit einem Package verknüpft wurde, den entsprechenden Fremdschlüssel.
\item \textbf{packageId} (Primary Key, int, NOT NULL) \newline
Dieses Attribut enthält von jedem Package, welches mit einem Update verknüpft wurde, den entsprechenden Fremdschlüssel.
\end{itemize}
\subsubsection{Tabelle package}
Diese Tabelle beinhaltet alle Informationen die ein Package benötigt.
\begin{itemize}
\item \textbf{id} (Primary Key, Auto Increment, int, NOT NULL) \newline
Wird für die Beziehung zur Tabelle update benötigt.
\item \textbf{name} (varchar(50), NOT NULL) \newline
Das ist der Titel des Package, die Stringgrösse von diesem Attribut wurde auf 50 Zeichen gesetzt.
\item \textbf{typeId} (int, NOT NULL) \newline
Dies ist der Fremdschlüssel der Tabelle type, er wird für die Beziehung zwischen den Tabellen package und type benutzt.
\end{itemize}
\subsubsection{Tabelle type}
Diese Tabelle beinhaltet alle Typen der Packages. Sie wird benötigt um Redundanz und somit Dateninkonsistenz zu vermeiden. \newline
\begin{itemize}
\item \textbf{id} (Primary Key, int, Auto Increment, NOT NULL) \newline
Wird für die Beziehung zwischen den Tabellen type und package benötigt. 
\item \textbf{type} (varchar(10), NOT NULL) \newline 
Dieses Attribut beinhaltet den Namen des Typs. Die Stringgrösse wird auf 10 gesetzt, da die momentan benötigten Typen relativ kurz sind
\end{itemize}
\subsection{Sofwarearchitektur}
Das Programm wird mit der Sprache PHP entwickelt. Das ganze Programm wird nach dem MVC Konzept\footnote{MVC nach Vorlesung Webprogrammieren mit PHP\textbackslash MySQL} konzipiert. Das Programm muss folgende Funktionen anbieten.
\begin{itemize}
\item Suchen von Updates und Packages
\item Erstellen, ändern und löschen von Updates
\item Erstellen, ändern und löschen von Packages
\item Anzeigen der Packages und den beinhalteten Updates
\end{itemize}
Durch diese gewünschten Funktionen entsteht folgendes Architektur.
\includepdf[pages={1}]{C:/inetpub/wwwroot/auswertung/doc/img/Klassendiagramm.pdf}
\subsubsection{Model}
Das Model ist für die SQL Abfragen zuständig. Jede Klasse hat einen Konstruktor und einen Dekonstruktor. Der Konstruktor baut jeweils die Verbindung zur SQL Datenbank auf und der Dekonstruktor baut sie wieder ab.  \newline \newline
Die anderen Methoden sind jeweils zuständig um die Einträge zu speichern, ändern und zu löschen, sowie benutzerspezifische Suchabfragen durchzuführen und dementsprechend die gefundenen Datensätze zurückzugeben. 
\subsubsection{Controller}
Der Controller ist für die Logik des Programm zuständig, der Controller arbeitet mit den POST und GET Werte und weiss dadurch welche Funktion im Model aufgerufen werden muss. Nach der Abfrage der Datenbank durch das Model, hat der Controller Zugriff auf die gewünschten Daten, nun wird anhand der GET und POST Werte entschieden, welche Datei des Packages View aufgerufen werden soll.\newline \newline
Die Verbindung der Controllerklassen mit den Modelklassen wird einfach implementiert sein. Eine Controllerklasse hat nur Zugriff auf die entsprechende Modelklasse, dies bedeutet das die Controllerklasse \textit{packages} hat nur Zugriff auf die Modelklasse \textit{class.packages}. \newline \newline 
Die einzige Klasse, die diese Regel nicht befolgt ist die Klasse \textit{class.resolver}.
\subsubsection{class.resolver}
Die Klasse class.resolver hat die wichtigste Funktion in der Logik. Sie überprüft, welche Werte sich im POST und GET befinden, und führt somit die entsprechende Funktion in den entsprechenden Klassen aus. Die Klasse class.resolver wurde aus der Vorlesung Webprogrammieren mit PHP\textbackslash MySQL entnommen.
\subsubsection{View}
In der View befinden sich alle Dateien, die für das Visualisieren der Daten zuständig sind. Sie werden im Controller implementiert und stellen die entsprechenden abgefragten Daten grafisch dar.
\newpage
\subsubsection{index.php und JavaScript}
In dieser Datei befindet sich das visuelle Grundgerüst der Web Applikation und ein paar JavaScript Funktionen. Die JavaScript Funktionen sind für die Validierung der Benutzereingabe zuständig. Durch die Implementation der JavaScript Funktionen werden die Eingabefelder vor dem Absenden validiert. Folgende Eingaben werden von JavaScript überprüft.
\begin{itemize}
\item \textbf{Suchfelder} \newline
Es darf nur ein Suchfeld, sobald der Benutzer ein Suchfeld ausgefüllt hat, werden die anderen Felder gräulich hinterlegt und der Benutzer kann die Suche ausführen.
Das Suchfeld kb darf nur Zahlen beinhalten, falls im Suchfeld andere Zeichen vorhanden sind, wird der Suchknopf deaktiviert und eine Fehlermeldung erscheint.
Das Erscheinungsdatum darf nur ein Datum haben im Format dd.mm.YYYY haben, ansonsten wird der Suchknopf deaktiviert und eine Fehlermeldung erscheint.
\item \textbf{Update Management}
Der Knopf um das Update zu speichern wird erst aktiviert, wenn in den Feldern Name, KB und Erscheinungsdatum gültige Werte vorhanden sind.
Sobald ein Package für das Update ausgewählt wird, wird der Suchknopf deaktiviert solange der Benutzer das Package wieder abwählt oder ein gültiges Freigabedatum für den Typ dieses Packages eingibt. Diese Validierung gilt für das Eröffnen oder Ändern eines Eintrags.
\item \textbf{Package Management} 
Der Knopf um das Package zu speichern wird erst aktiviert, wenn in dem Feld Name ein gültiger Wert eingegeben wurde. Diese Validierung gilt für das Eröffnen oder 
Ändern eines Eintrags.
\end{itemize}
\newpage
\section{Entwurf}
Die Webseite besteht aus drei verschiedenen Ansichten. Eine für die Suche, eine um Updates zu mutieren und eine um Packages zu mutieren.
\begin{figure}[htbp]
		\centering
	\includegraphics[width= 10cm]{C:/inetpub/wwwroot/auswertung/doc/img/entwurf-suchen.jpg}
		\label{fig:Entwurf Suchen}
\end{figure}
\begin{figure}[htbp]
		\centering
	\includegraphics[width= 10cm]{C:/inetpub/wwwroot/auswertung/doc/img/entwurf-update.jpg}
		\label{fig:Entwurf Update}
\end{figure}
\begin{figure}[htbp]
		\centering
	\includegraphics[width= 10cm]{C:/inetpub/wwwroot/auswertung/doc/img/entwurf-package.jpg}
		\label{fig:Entwurf Package}
\end{figure}
\newpage
\section{Testkonzept}
\subsection{Einleitung}
Aus Zeitgründen wurde

\section{Fazit}
\subsection{Review}
Der erste Teil des Projekts wurde vollständig implementiert und die Applikation, kann sobald die Dateien auf die produktive Umgebung verschoben werden genutzt werden.
Das ganze Projekt war relativ einfach einzuschätzen, da nur Anforderungen und keine Wünsche vom Auftraggeber gegeben wurden. Jedoch habe ich die Zeit ein wenig unterschätzt, da ich nicht so gewandt bin mit PHP. Zusätzlich musste ich mich noch Leider wurde nicht das gesamte Testkonzept implementiert, da ich zwar PHPUnit installieren konnte, jedoch PHPUnit keine Teste durchführte. Als das Suchen einer Lösung zu zeitintensiv wurde, habe ich mich entschieden manuelle Testklassen zu schreiben, die in der CMD das Resultat der Tests ausgeben. 
Der fertige erste Teil des Projekt wurde vom Auftragsgeber kontrolliert und angenommen.
\subsection{Ausblick}
Es stehen noch folgende offene Arbeiten aus:
\begin{itemize}
\item Die restlichen Tests implementieren
\item Das Kopieren der Dateien auf den produktiven Server
\item Die Implementation des zweiten Teil mit Planung, Entwicklung, Realisierung und Testen
\end{itemize}
\newpage
\includepdf[pages=1,pagecommand=\section{Projetkplan}]{C:/inetpub/wwwroot/auswertung/doc/img/Planung.pdf}
\begin{thebibliography}{4}
\bibitem{1}
	Klaus Pohl / Chris Rupp (Juni 2011):
	\emph{Basiswissen Requirements Engineering}
\bibitem{2}
	Mahbouba Gharbi / Arne Koschel / Andreas Rausch / Gernot Starke (Dezember 2012):
	\emph{Basiswissen für Softwarearchitekten}
\bibitem{3}
	Andreas Spillner / Tilo Linz (September 2012):
	\emph{Basiswissen Softwaretest}
\bibitem{4}
	Microsoft SQL Server Driver for PHP:
	http://php.net/manual/en/book.sqlsrv.php
\end{thebibliography}
\end{document}
