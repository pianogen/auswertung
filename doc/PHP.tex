\documentclass{article}
\usepackage[latin1]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{threeparttable}
\usepackage{lscape}
\usepackage{amsmath}
\usepackage{pdfpages}

\begin{document}

\title{Automatisierung der WSUS Auswertung
\\ Ein Projekt mit PHP\textbackslash MSSQL}
\author{Gennaro Piano}
\date{\today}

\maketitle

\begin{figure}[htbp]
		\centering
	\includegraphics[width=10cm]{wsus.jpg}
		\label{fig:logo}
\end{figure}

\newpage
\tableofcontents
\newpage
\section{Einleitung}
\subsection{Ausgangslage}
Wir bieten unseren Kunden die Möglichkeit die Windows Updates über unserem WSUS Server herunterzuladen. Durch dieses Angebot muss sich der Kunde nicht mehr über fehlerhaften Updates kümmern, da wir die Updates zuerst in einer Testumgebung testen und diese danach freigeben. Um die Updateverwaltung einfach zu halten wurden auf dem WSUS Server Produktklassen erstellt. Computer und Server von Kunden die unser Angebot nutzen möchten, werden den entsprechenden Produktklassen zugeteilt. Updates die freigegeben sind werden wiederum den entsprechenden Produktklassen zugeteilt und somit auf den Geräten der Kunden installiert. Dieses System ist gut durchdacht, jedoch ist es sehr kompliziert diese Daten auszuwerten. \newline \newline
Um die Daten auszuwerten werden jedes Quartal alle freigegebenen Updates manuell in einer Excel Datei aufgenommen. Jedes Update wird danach in die entsprechende Produktklasse kopiert. Auf einem weiterem Excel Blatt wird ausgewertet, welcher Benutzer welche Produktklassen benötigt. Dieser Prozess ist sehr zeitintensiv und kostet pro Quartal circa eins bis zwei Arbeitstage.
\subsection{Ziel der Arbeit}
Um den Aufwand zu kürzen soll der Ablauf des Prozesses so weit wie möglich automatisiert werden. Dies soll mit PHP und einem MS SQL Server realisiert werden. Im ersten Schritt soll die Verbindung zwischen den Updates und den Produktklassen programmiert werden. Als zweiter Schritt werden die Kunden hinzugefügt und die Auswertung automatisiert. Diese Arbeit befasst sich mit dem ersten Schritt des Projekts.
\subsection{Sourcecode}
Der Sourcecode der Applikation wurde aus Platzgründen nicht in die Dokumentation eingefügt, jedoch kann er direkt aus dem GitHub Repository heruntergeladen werden. Der Link lautet https://github.com/pianogen/auswertung.
\subsection{Bemerkung}
Die Applikation wird auf einer virtuellen Maschine entwickelt und getestet, sobald alle das Projekt abgeschlossen ist, werden die Dateien auf den produktiven Server kopiert.
\newpage
\section{Requierements}
\subsection{Einleitung}
\textbf{Zweck} \newline
Dieser Teil des Dokuments befasst sich mit den Anforderungen, des Projekts. Diese Anforderungen werden mit dem Auftraggeber angeschaut. Erst wenn die Anforderungen vom Auftraggeber bestätigt worden sind und nach seiner Meinung alles abgedeckt ist, wird das Projekt fortgeführt.
\newline
\newline
\textbf{Systemumfang} \newline
Das System wird für den internen Gebrauch entwickelt und soll von aussen nicht zugänglich sein. Somit besteht keine Gefahr, die Applikation vor unerlaubten Zugriff zu schützen, da dies die Firewall handhabt. 
\newline
\newline
\textbf{Auftraggeber} \newline
Der Auftraggeber dieses Projekts ist zugleich der interne technische Leiter der Firma. Somit wird das Projekt als internes Projekt gehandhabt. Der technische Leiter ist kein Programmierer und stellt deswegen keine technische Anforderungen an das Projekt. Der technische Leiter wird für dieses Projekt als Kunde angesehen.\newline \newline
\subsection{Allgemeine Übersicht}
\textbf{Systemumfeld} \newline
Diese Applikation benötigt einen Webserver und eine Schnittstelle zu einer Microsoft SQL Datenbank. Der WSUS Server gehört auch zum Systemumfeld, jedoch ist die Verbindung zwischen dem WSUS Server und der Applikation nur abstrakt, da die entnommenen Informationen aus dem WSUS Server manuell in der Applikation aufgenommen werden.
\begin{figure}[htbp]
		\centering
	\includegraphics[width=10cm]{C:/inetpub/wwwroot/auswertung/doc/img/Systemumfeld.jpg}
		\label{fig:Systemumfeld}
\end{figure}
\newpage
\parindent0pt \textbf{Architekturbeschreibung} \newline
Die PHP Applikation wird auf dem schon vorhandenen Webserver implementiert. Es handelt sich um einen IIS, dies ist der Webserver von Microsoft. Der IIS unterstützt von sich aus kein PHP. Somit muss der PHP Interpreter nachgerüstet werden. Der PHP Interpreter wird mit dem integrierten Webplattform Installer installiert. Für die Datenbankanbindung wird ebenfalls der vorhandene SQL Server benutzt. Auf diesem Server wird eine neue Datenbank und ein neuer Datenbankbenutzer erstellt. Der neue Benutzer wird nur auf diese Datenbank Zugriff haben, zugleich wird er der einzige Benutzer sein, der auf die neue Datenbank Zugriff hat. Der Webserver und der SQL Server befinden sich physikalisch auf dem gleichen Server, somit ist hardwaremässig nur ein Server von den Veränderungen betroffen. Der PHP Interpreter benötigt eine Schnittstelle um auf die Datenbank zu lesen und zu schreiben, die Schnittstelle zwischen PHP und einem Microsoft SQL Server wird nicht automatisch installiert und muss somit manuell nachinstalliert werden.
\newline
\newline
\textbf{Systemfunktionalität} \newline
Das Use Case Diagramm soll die Funktionalität des Systems aufzeigen.
\begin{figure}[htbp]
		\centering
	\includegraphics[width=14.5cm]{C:/inetpub/wwwroot/auswertung/doc/img/Use_Case.jpg}
		\label{fig:UseCaseDiagramm}
\end{figure}
\newpage
\parindent0pt \textbf{Nutzer und Zielgruppen} \newline
Der Hauptnutzer ist zugleich der Auftraggeber dieses Projekts. Neben dem Auftraggeber wird die Webapplikation auch von seinem Stellvertreter benutzt werden, dies wird jedoch sehr selten der Fall sein. Der Zugriff auf die Webapplikation wird für alle Benutzer des Unternehmens möglich sein, dies ist bei der momentanen Excel Datei auch der Fall.
\newline
\newline
\textbf{Annahmen} \newline
Der zweite Teil des Projekts wird wie oben bereits erwähnt erst später entwickelt. In dieser Dokumentation wird auf den zweiten Teil des Projekts bewusst nicht eingegangen, da dies ansonsten den Umfang dieses Dokuments sprengen würde.
\subsection{Anforderungen}
\begin{itemize}
\item Die Applikation muss dem Benutzer ermöglichen, neue Updateeinträge durch eine Maske in die Datenbank einzutragen. 
\item Die Applikation muss dem Benutzer ermöglichen, über eine Maske nach Updateeinträge auf der Datenbank zu suchen. 
\item Die Applikation muss dem Benutzer ermöglichen, über eine Maske Updateeinträge auf der Datenbank zu verändern und zu löschen. 
\item Die Applikation muss dem Benutzer ermöglichen, neue Packageeinträge durch eine Maske in die Datenbank einzutragen. 
\item Die Applikation muss dem Benutzer ermöglichen, über eine Maske nach Packageeinträge auf der Datenbank zu suchen. 
\item Die Applikation muss dem Benutzer ermöglichen, über eine Maske Packageeinträge auf der Datenbank zu verändern und zu löschen. 
\item Die Applikation muss dem Benutzer alle Packagezuweisungen eines Updateeintrags aufzeigen, wenn der Benutzer den Updateeintrag anschaut. 
\item Die Applikation muss dem Benutzer ermöglichen, über eine Maske ein Packageeintrag, dem entsprechendem Typ zuzuordnen. 
\item Andersum soll die Applikation dem Benutzer alle Updateeinträge eines Packages aufzeigen, wenn der Benutzer den Packageeintrag anschaut. 
\item Sobald der Benutzer einen neuen Updateeintrag eröffnen will, soll die Applikation ihm die Packages aufzeigen, damit er sogleich die Verknüpfung erstellen kann.
\end{itemize}
\newpage
Beim Speichervorgang des neuen Eintrag soll das System folgende Einträge die durch den Benutzer erfolgt sind überprüfen:
\begin{itemize}
\item Der Titel eines Updateeintrag darf nicht leer sein.
\item Die KB Nummer eines Updateeintrags darf nicht leer sein und muss einen numerischen Wert haben.
\item Das Veröffentlichungsdatum eines Updateeintrags darf nicht leer sein.
\item Ein Updateeintrag kann mehreren Packages zugeteilt werden.
\item Datumsfelder werden nur als dd.mm.JJJJ angenommen
\item Ein Updateeintrag kann keinem Package zugeteilt werden.
\item Ein Update kann von Microsoft auch zurückgezogen werden, dies sollte ebenfalls im Datensatz aufgenommen werden können. Dieser kann auch leer sein.
\item Sobald der ein Update mindestens einem Package zugeteilt worden ist, muss der Benutzer auch ein Approvement Daten setzen. 
\item Falls das Update keinem Package zugeteilt worden ist, darf kein Approvement Datum gesetzt sein.
\item Der Titel eines Packageeintrag darf nicht leer sein.
\item Der Typ eines Packageeintrag darf nicht leer sein.
\end{itemize}
Falls eine dieser Überprüfungen fehlschlägt, darf der Eintrag nicht gespeichert werden. Die Anforderungen des Speicher- und Änderungsvorgangs sind identisch. Das Löschen eines Updateeintrag muss die Verknüpfung zu den zugeteilten Packages ebenfalls löschen. Das Löschen eines Packageeintrag muss wiederum die Verknüpfungen zu den implementierten Updates löschen.
\newpage
\section{Entwicklung}
\subsection{Datenbank}
Um die aufgenommenen Updates zu speichern, wird eine Datenbank benötigt. Vor der Erstellung der Datenbank wurde ein Entity Relationship Diagram erstellt. Auf der nächsten Seite befindet sich ein genaue Beschreibung der Tabellen und Attributen. Der Text in Klammern beschreibt die Eigenschaften der Attributen.
\begin{figure}[htbp]
		\centering
	\includegraphics[width=14.5cm]{C:/inetpub/wwwroot/auswertung/doc/img/Datenbank.jpg}
		\label{fig:Datenbank}
\end{figure}
\newpage
\subsubsection{Tabelle update}
In dieser Tabelle befinden sich alle Informationen, die ein Update benötigt.
\begin{itemize}
\item \textbf{id} (Primärschlüssel, int, auto increment, NOT NULL) \newline 
Wird für die Verbindung zur Tabelle update\_package benötigt. 
\item \textbf{name} (varchar(400), NOT NULL) \newline 
Das ist der Titel des Updates, da der Titel recht lange sein kann, wird der String auf 400 Zeichen begrenzt. Diese Attribut ist ein Pflichtfeld.
\item \textbf{kb} (int, NOT NULL) \newline
Das ist die KB Nummer\footnote{Knowlegde Base Number: Wird für Microsoft genutzt, um Updates eindeutig zu kennzeichnen} des Updates. Dieses Attribut wurde nicht als Primary Key benutzt, da es schon vorgekommen ist, das zwei Updates die selbe KB Nummer haben. Dieses Attribut ist ein Pflichtfeld, da jedes Update eine KB Nummer hat.
\item \textbf{release} (date, NOT NULL) \newline
Dieses Attribut beinhaltet das Erscheinungsdatum des Updates. Es ist ein Pflichtfeld, da jedes Update dass eingetragen wird, schon erschienen ist.
\item \textbf{decline} (date) \newline
Falls ein Update von Microsoft wegen einem Bug zurückgenommen wird, wird dieses Datum in diesem Feld eingefügt.
\item \textbf{approve\_clt} (date)  \newline 
Dieses Attribut beinhaltet das Datum, an dem das Update für die Clients freigegeben wurde. Dieses Feld darf leer sein, da nicht jedes Update zwingend für Clients ist.
\item \textbf{approve\_srv} (date) \newline
Dieses Attribut beinhaltet das Datum, an dem das Update für die Server freigegeben wurde. Dieses Feld darf leer sein, da nicht jedes Update zwingend für Server ist.
\end{itemize}
\subsubsection{Tabelle update\_package}
Diese Tabelle ist eine Zwischentabelle. Durch diese Tabelle wird die Beziehung zwischen den Tabellen update und package ermöglicht. In dieser Tabelle besteht der Primärschlüssel aus zwei Attributen.
\begin{itemize}
\item \textbf{updateId} (Primary Key, int, NOT NULL) \newline 
Dieses Attribut enthält von jedem Update, welches mit einem Package verknüpft wurde, den entsprechenden Fremdschlüssel.
\item \textbf{packageId} (Primary Key, int, NOT NULL) \newline
Dieses Attribut enthält von jedem Package, welches mit einem Update verknüpft wurde, den entsprechenden Fremdschlüssel.
\end{itemize}
\subsubsection{Tabelle package}
Diese Tabelle beinhaltet alle Informationen die ein Package benötigt.
\begin{itemize}
\item \textbf{id} (Primary Key, Auto Increment, int, NOT NULL) \newline
Wird für die Beziehung zur Tabelle update benötigt.
\item \textbf{name} (varchar(50), NOT NULL) \newline
Das ist der Titel des Package, die Stringgrösse von diesem Attribut wurde auf 50 Zeichen gesetzt.
\item \textbf{typeId} (int, NOT NULL) \newline
Dies ist der Fremdschlüssel der Tabelle type, er wird für die Beziehung zwischen den Tabellen package und type benutzt.
\end{itemize}
\subsubsection{Tabelle type}
Diese Tabelle beinhaltet alle Typen der Packages. Sie wird benötigt um Redundanz und somit Dateninkonsistenz zu vermeiden. \newline
\begin{itemize}
\item \textbf{id} (Primary Key, int, Auto Increment, NOT NULL) \newline
Wird für die Beziehung zwischen den Tabellen type und package benötigt. 
\item \textbf{type} (varchar(10), NOT NULL) \newline 
Dieses Attribut beinhaltet den Namen des Typs. Die Stringgrösse wird auf 10 gesetzt, da die momentan benötigten Typen relativ kurz sind
\end{itemize}
\subsection{Sofwarearchitektur}
Das Programm wird mit der Sprache PHP entwickelt. Das ganze Programm wird nach dem MVC Konzept\footnote{MVC nach Vorlesung Webprogrammieren mit PHP\textbackslash MySQL} konzipiert. Das Programm muss folgende Funktionen anbieten.
\begin{itemize}
\item Suchen von Updates und Packages
\item Erstellen, ändern und löschen von Updates
\item Erstellen, ändern und löschen von Packages
\item Anzeigen der Packages und den beinhalteten Updates
\end{itemize}
Durch diese gewünschten Funktionen entsteht folgendes Architektur.
\includepdf[pages={1}]{C:/inetpub/wwwroot/auswertung/doc/img/Klassendiagramm.pdf}
\subsubsection{Model}
Das Model ist für die SQL Abfragen zuständig. Jede Klasse hat einen Konstruktor und einen Dekonstruktor. Der Konstruktor baut jeweils die Verbindung zur SQL Datenbank auf und der Dekonstruktor baut sie wieder ab.  \newline \newline
Die anderen Methoden sind jeweils zuständig um die Einträge zu speichern, ändern und zu löschen, sowie benutzerspezifische Suchabfragen durchzuführen und dementsprechend die gefundenen Datensätze zurückzugeben. 
\subsubsection{Controller}
Der Controller ist für die Logik des Programm zuständig, der Controller arbeitet mit den POST und GET Werte und weiss dadurch welche Funktion im Model aufgerufen werden muss. Nach der Abfrage der Datenbank durch das Model, hat der Controller Zugriff auf die gewünschten Daten, nun wird anhand der GET und POST Werte entschieden, welche Datei des Packages View aufgerufen werden soll.\newline \newline
Die Verbindung der Controllerklassen mit den Modelklassen wird einfach implementiert sein. Eine Controllerklasse hat nur Zugriff auf die entsprechende Modelklasse, dies bedeutet das die Controllerklasse \textit{packages} hat nur Zugriff auf die Modelklasse \textit{class.packages}. \newline \newline 
Die einzige Klasse, die diese Regel nicht befolgt ist die Klasse \textit{class.resolver}.
\subsubsection{class.resolver}
Die Klasse class.resolver hat die wichtigste Funktion in der Logik. Sie überprüft, welche Werte sich im POST und GET befinden, und führt somit die entsprechende Funktion in den entsprechenden Klassen aus. Die Klasse class.resolver wurde aus der Vorlesung Webprogrammieren mit PHP\textbackslash MySQL entnommen.
\subsubsection{View}
In der View befinden sich alle Dateien, die für das Visualisieren der Daten zuständig sind. Sie werden im Controller implementiert und stellen die entsprechenden abgefragten Daten grafisch dar.
\newpage
\subsubsection{index.php und JavaScript}
In dieser Datei befindet sich das visuelle Grundgerüst der Web Applikation und ein paar JavaScript Funktionen. Die JavaScript Funktionen sind für die Validierung der Benutzereingabe zuständig. Durch die Implementation der JavaScript Funktionen werden die Eingabefelder vor dem Absenden validiert. Folgende Eingaben werden von JavaScript überprüft.
\begin{itemize}
\item \textbf{Suchfelder} \newline
Es darf nur ein Suchfeld, sobald der Benutzer ein Suchfeld ausgefüllt hat, werden die anderen Felder gräulich hinterlegt und der Benutzer kann die Suche ausführen.
Das Suchfeld kb darf nur Zahlen beinhalten, falls im Suchfeld andere Zeichen vorhanden sind, wird der Suchknopf deaktiviert und eine Fehlermeldung erscheint.
Das Erscheinungsdatum darf nur ein Datum haben im Format dd.mm.YYYY haben, ansonsten wird der Suchknopf deaktiviert und eine Fehlermeldung erscheint.
\item \textbf{Update Management}
Der Knopf um das Update zu speichern wird erst aktiviert, wenn in den Feldern Name, KB und Erscheinungsdatum gültige Werte vorhanden sind.
Sobald ein Package für das Update ausgewählt wird, wird der Suchknopf deaktiviert solange der Benutzer das Package wieder abwählt oder ein gültiges Freigabedatum für den Typ dieses Packages eingibt. Diese Validierung gilt für das Eröffnen oder Ändern eines Eintrags.
\item \textbf{Package Management} 
Der Knopf um das Package zu speichern wird erst aktiviert, wenn in dem Feld Name ein gültiger Wert eingegeben wurde. Diese Validierung gilt für das Eröffnen oder 
Ändern eines Eintrags.
\end{itemize}
\newpage
\section{Entwurf}
Die Webseite besteht aus drei verschiedenen Ansichten. Eine für die Suche, eine um Updates zu mutieren und eine um Packages zu mutieren.
\begin{figure}[htbp]
		\centering
	\includegraphics[width= 10cm]{C:/inetpub/wwwroot/auswertung/doc/img/entwurf-suchen.jpg}
		\label{fig:Entwurf Suchen}
\end{figure}
\begin{figure}[htbp]
		\centering
	\includegraphics[width= 10cm]{C:/inetpub/wwwroot/auswertung/doc/img/entwurf-update.jpg}
		\label{fig:Entwurf Update}
\end{figure}
\begin{figure}[htbp]
		\centering
	\includegraphics[width= 10cm]{C:/inetpub/wwwroot/auswertung/doc/img/entwurf-package.jpg}
		\label{fig:Entwurf Package}
\end{figure}
\newpage
\section{Testkonzept}
\subsection{Teststratgie}
Aus Zeitgründen werden nur Modelklassen als Units getestet. Die Modelklasse sind hauptsächlich für die Datenbankanbindung und den Datenbankabfragen zuständig. Der Controller wird erst bei dem Intergrationstest herangezogen. Und die View wird zum Schluss bei den Systemtest getestet. Diese Teststrategie mach durchaus Sinn, da um die Controllerklassen komplett zu testen, die Resultate aus den Datenbankabfragen benötigt werden. Die View wird nur visuell getestet, da die Viewdateien relativ klein und übersichtlich sind. Der Systemtest wird überprüfen, ob die Anforderungen erfüllt wurden. Zum Schluss wird es noch einen Abnahmetest durch den Auftraggeber geben, dieser Test entscheidet, ob die Software freigegeben werden kann. 
\subsection{Testwerkzeug}
Es wurde versucht, das PHPUnit Modul als Testwerkzeug in die Applikation zu implementieren, jedoch hat das nicht wie gewünscht geklappt. Somit wurde eine PHP Klasse mit manuellen assert-Methoden erstellt. Es wurde ein eigenes Testwerkzeug erstellt, welches durch die cmd aufgerufen werden kann, und die Testresultate in der cmd ausgibt. Dieses Testwerkzeug wird für die Unit und Integrationstests benutzt.
\subsection{Unit Tests der Modelklassen}
In der Modelklasse werden alle Methoden vereinzelt getestet, die benötigten GET- und POST-Werte werden mit Dummy Werte ausgeführten. In der untenstehenden Tabelle werden alle benötigten Tests aufgelistet. Die Resultatet werden im Nachhinein in der Tabelle eingetragen. \newline \newline
\begin{tabular}{|l|l|p{4cm}|p{3cm}|}
\hline
\textbf{Name} & \textbf{Wo} & \textbf{Was wird getestet} & \textbf{Resultat} \\ \hline
constructTest() & Allen Klassen & Ob die Datenbankverbindung aufgebaut werden kann & Erwartet: True \newline Erfolgreich \\ \hline
findIdTest() & mdl\_updates & Mit Hilfe eines GET-Werts wird ein Updates gesucht. & Erwartet: NotNull \newline Erfolgreich \\ \hline
gpTest() & mdl\_updates & Es wird nach allen Packages gesucht & Erwartet: NotNull \newline Erfolgreich \\ \hline
gopTest() & mdl\_updates & Mit Hilfe eines GET-Werts werden alle Packages, die nicht für das Update sind gesucht & Erwartet: NotNull \newline Erfolgreich \\ \hline
\end{tabular}
\newpage
\begin{tabular}{|p{3cm}|l|p{4cm}|p{3cm}|}
\hline
\textbf{Name} & \textbf{Wo} & \textbf{Was wird getestet} & \textbf{Resultat} \\ \hline
pTuTest() & mdl\_updates & Mit Hilfe eines GET-Werts werden alle Packages für das Update gesucht & Erwartet: NotNull \newline Erfolgreich \\ \hline
saveTest() & mdl\_updates & Es wird ein neuer Datensatz gespeichert & Erwartet: True \newline Erfolgreich \\ \hline
updateTest() & mdl\_updates & Es wird ein vorhandener Datensatz geändert & Erwartet: True \newline Erfolgreich \\ \hline
deleteTest() & mdl\_updates & Es wird ein vorhandener Datensatz gelöscht & Erwartet: True \newline Erfolgreich \\ \hline
gspTest() & mdl\_packages & Mit Hilfe eines GET-Werts wird ein Package gesucht & Erwartet: NotNull \newline Erfolgreich \\ \hline
saveTest() \newline updateTest() \newline deleteTest() & mdl\_packages & Gleiches Tests wie bei den Methoden der Update-Klasse & Erwartet: True \newline Erfolgreich \\ \hline
uTpTest() & mdl\_packages & Mit Hilfe eines GET-Werts werden alle Updates für das Package gesucht & Erwartet: NotNull \newline Erfolgreich \\ \hline
getTypesTest() & mdl\_packages & Mit Hilfe eines GET-Werts wird der Typ des Packages ermittelt & Erwartet: NotNull \newline Erfolgreich \\ \hline
fAuTest() & mdl\_search & Es sollen alle Updates zurückgegeben werden & Erwartet: NotNull \newline Erfolgreich \\ \hline
fspTest() & mdl\_search & Mit Hilfe eines Suchbegriffes alle betroffenen Packages zurückgeben & Erwartet: NotNull \newline Erfolgreich \\ \hline
gatTest() & mdl\_search & Alle Typen zurückgegeben & Erwartet: NotNull \newline Erfolgreich \\ \hline
\end{tabular}
\newline \newline \newline
Das sind die wichtigsten Test die für diese Applikation benötigt werden, man könnte noch Tests implementieren, die falsche Werte zurückgeben müssen, jedoch wurde wegen Zeitgründen auf diese Tests verzichtet.
\newpage
\subsection{Integrationstests}
Die Integrationstest koppeln das Model und den Controller zusammen und überprüfen, ob das Zusammenspiel der beiden Komponenten auf Eingaben richtig reagiert. Der Aufbau ist bei jedem Integrationstest der Gleiche. Die Klasse class.resolver wird mit verschiedenen Eingaben aufgerufen und überprüft, ob Sie die richtigen Klassen und Methoden im Controller und im Model aufrufen. Zum Schluss wird überprüft, ob der Controller die richtigen Werte der View übergibt. \newline \newline
Diese Tests sind sehr aufwendig und nur teilweise implementiert worden. Auf die einzelnen Tests wird nicht weiter eingegangen, da diese wie schon vorhin gesagt, im Aufbau sehr ähnlich sind.
\subsection{Systemtest}
Der Systemtest wird genutzt um zu überprüfen, ob alle Anforderungen erfüllt wurden. Bei dem Systemtest wird die Applikation aus den Augen des Auftraggebers betrachtet und dadurch entschieden, ob die Anforderung erfüllt wurde oder nicht.
\newline \newline
\textbf{Speichern, Ändern und Löschen von Updates und Packages} \newline
Der Benutzer kann in jeweils zwei verschiedenen Masken Updates und Packages hinzufügen, ändern oder löschen. Eingabefelder die ein bestimmtes Format benötigen, werden vor dem Absenden überprüft. \newline \newline
\textbf{Suchen von Updates und Packages} \newline
Diese Anforderung wurde erfüllt, der Benutzer kann nach Updates und Packages suchen. Die Sucheingaben werden vor dem Absenden auf Richtigkeit überprüft. Somit kann der Benutzer keine Suchanfrage starten, wenn er nichts eingegeben hat oder unzulässige Zeichen benutzt. \newline \newline
\textbf{Dem Package einen Typ zuordnen} \newline
Der Benutzer muss jedem aufgenommenen Package einen Typ zuordnen, da jedes Packages einem Typ zugeordnet werden muss. Diese Aktion wird in der Package Management Maske gemacht. \newline \newline
\textbf{Updates einen bestimmten Package aufzeigen} \newline
Sobald der Benutzer ein Package öffnet werden auf der unteren Hälfe der Seite die Updates, die sich in diesem Package befinden, aufgezeigt. \newline \newline
\textbf{Verknüpfung Updates Packages} \newline
Diese Anforderung wurde erfüllt. Im Update Management kann der Benutzer das Update jederzeit einem Package hinzufügen oder wieder entfernen, ganz egal ob das Update schon vorhanden ist oder nicht. \newpage
\textbf{Der Titel eines Updateeintrags darf nicht leer sein} \newline
Diese Anforderung wurde mit Hilfe von JavaScript erfüllt, solange der Titel leer ist, ist der Knopf um den Eintrag zu speichern oder zu ändern deaktiviert.
\newline \newline
\textbf{KB Nummer darf nicht leer und muss numerisch sein} \newline
Diese Anforderung wurde mit Hilfe von JavaScript erfüllt, solange der Wert der KB Nummer nicht numerisch ist, ist der Knopf um den Eintrag zu speichern oder zu ändern deaktiviert. \newline \newline
\textbf{Veröffentlichungsdatum darf nicht leer sein} \newline
Diese Anforderung wurde mit Hilfe von JavaScript erfüllt, solange das Feld des Veröffentlichungsdatum leer ist, ist der Knopf um den Eintrag zu speichern oder zu ändern deaktiviert. \newline \newline
\textbf{Update kann mehreren Packages zugeteilt werden} \newline
Diese Anforderung wurde erfüllt. Im Update Management werden alle Packages, egal ob das Update dem Package zugeteilt wurde oder nicht, angezeigt. Der Benutzer kann jeweils durch Auswahlboxen auswählen, welchem Package das Update zugeteilt ist und welchem nicht. \newline \newline
\textbf{Update kann keinem Package zugeteilt sein}
Diese Anforderung wurde erfüllt. Ein Update ohne Packagezuteilung gespeichert werden. \newline \newline
\textbf{Rückzug eines Updates} \newline
Diese Anforderung wurde erfüllt. Für diese Anforderung wurde ein eigenes Feld definiert. Sobald ein Update von Microsoft zurückgezogen wurde, kann man das Datum in diesem definierten Feld eingeben. \newline \newline
\textbf{Datumsformat} \newline
\newline \newline
\textbf{Packagezuteilung und Freigabedatum} \newline
Diese Anforderung wurde teilweise erfüllt. Sobald der Benutzer ein Freigabedatum eines Updates setzt und keine Packages auswählt, wird der Knopf um den Datensatz zu speichern deaktiviert. \newline \newline
\textbf{Korrektes Speichern eines Packages} \newline
Diese Anforderung wurde erfüllt. Ein Package kann gespeichert werden, sobald ein Titel eingetragen worden ist und ein Typ ausgewählt wurde, ansonsten ist der Knopf um das Package zu speichern oder zu ändern deaktiviert. 
\newpage
\section{Fazit}
\subsection{Review}
Der erste Teil des Projekts wurde vollständig implementiert und die Applikation, kann sobald die Dateien auf die produktive Umgebung verschoben werden genutzt werden.
Das ganze Projekt war relativ einfach einzuschätzen, da nur Anforderungen und keine Wünsche vom Auftraggeber gegeben wurden. Jedoch habe ich die Zeit ein wenig unterschätzt, da ich nicht so gewandt bin mit PHP. Zusätzlich musste ich mich noch Leider wurde nicht das gesamte Testkonzept implementiert, da ich zwar PHPUnit installieren konnte, jedoch PHPUnit keine Teste durchführte. Als das Suchen einer Lösung zu zeitintensiv wurde, habe ich mich entschieden manuelle Testklassen zu schreiben, die in der CMD das Resultat der Tests ausgeben. 
Der fertige erste Teil des Projekt wurde vom Auftragsgeber kontrolliert und angenommen.
\subsection{Ausblick}
Es stehen noch folgende offene Arbeiten aus:
\begin{itemize}
\item Das Kopieren der Dateien auf den produktiven Server
\item Die Implementation des zweiten Teil mit Planung, Entwicklung, Realisierung und Testen
\end{itemize}
\newpage
\includepdf[pages=1,pagecommand=\section{Projetkplan}]{C:/inetpub/wwwroot/auswertung/doc/img/Planung.pdf}
\begin{thebibliography}{4}
\bibitem{1}
	Klaus Pohl / Chris Rupp (Juni 2011):
	\emph{Basiswissen Requirements Engineering}
\bibitem{2}
	Mahbouba Gharbi / Arne Koschel / Andreas Rausch / Gernot Starke (Dezember 2012):
	\emph{Basiswissen für Softwarearchitekten}
\bibitem{3}
	Andreas Spillner / Tilo Linz (September 2012):
	\emph{Basiswissen Softwaretest}
\bibitem{4}
	Microsoft SQL Server Driver for PHP:
	http://php.net/manual/en/book.sqlsrv.php
\end{thebibliography}
\end{document}